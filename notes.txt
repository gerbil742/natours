REST API's
- a piece of software that can be used by another piece of software to allow them to talk to each other 
- Representational State Transfer. Way of building apis to make them easy to consume. 
  - separate API into logical 'resources'
  - Expose (make the resources available) structured, 'resource'-based urls
  - use HTTP Methods to crud and not the url
  - send data as JSON
  - Be STATLESS
- REST architecture
  - all the data we want to share in  the api should be divided into logical resource
  - Object or representation of something, which has data assiciated with it. any info that can be named can be a 'resource'. Like tours, users or reviews. these are not 'verbs' tey are names
  - https://www.natours.com/addNewTour is the url. /addNewTour is the endpoint
    - This is a bad endpoint because it violates rule 3 above. Endpoints should only contain teh 'resource' and NOT the actions that can be performed on them. otherwise it will get messy
    - GET  /tours/7    use plural of the resource 
    - POST /tours    server should automatically figure out the id
    - PUT (client sends entire new object to update) of PATCH (client only sends part of object) /tours/7
    - DELETE /tours/7
    - these HTTP mehtods allow us to perform CRUD operations 
    - getToursByUser --> GET /users/3/tours
    - deleteToursByUser  --->  DELETE /users/3/tours/9
- stateless
  - all state is handled on the client. the request must contain ALL the info necessarry to process a certian request. the server should NOT have to remeber previous requests
  - Examples: loggedIn,   currentPage. state refers to a piece of data in the app that might change overtime
  - GET /tours/nextPage  this is bad because the server would need ot know what the current page is in order to send teh currentpage +1. it would have to handel the state server side
    - use GET /tours/page/6 instead


Request Response Cycle & Middleware
- when the express server recieves a request, the express app will then create a request and response object. The server processes the data in order to send back a meaningful response
- Middleware
  - in teh middle of recieving the request and sending the response. in express, essentially everything is a middleware. route functions can be intrepreted as middleware function 
    that only execute for specific routes
  - middleware is basically just a fucntion that can modify the incoming request data. called middleware because it stands between the request and the response
  - The middleware stack: the order thta middleware is executed is teh same as the order they are defined in teh code
  - the req and res objects that are created go through each middleware where they are processed, or some sort of function is called. At the end of each middleware, a next() function 
    is called which calles which executes the next middlewear whigh the same req and res objects.  
  - a request comes in from the client, we get the request and process it with the middlewares and then send it back on teh final middleware (route handler)
- Go to express.com -> resources > middleware to get a list of all the middleware express reccommends. there are things like body-parser listed there
- Flow: 1st, server is set to listen in server.js. a request comes in
  we go in to app.js and it goes down the middleware stack untill it hits the matching route then it gets sent to its corresponding handler
  Then, once in its route it will then execute its corresponding controller 
  finally, the controller will send back a response and end the request/response cycle
- We can create our own middlewares to add to teh middleware stack. if we include a 3rd argument, express knows that we are defining a middleware
  - app.use((req, res, next) => {
      console.log('Hello form the middleware');
      next(); // You need to call next() because otherwise the code wil just be stuck here
    });
  - Using middleware like this is a good way to add some additional into to our request
- You can write param middleware which only runs on a specific endpoint.
  router.param('id', tourController.checkID); 
  This middleware will only run on the /:id endpoint routes like getTour or updateTour
- Its better to define a param middleware to check for a valid id rather than make a function in teh tourController because it bett alligns with the philosophy of express.
  We should always try to work with the middleware stack as much as possible. each of the controllers dont have to worry about validation, they only do one thing.
  It also makes it easier to potentially add another controller that needs to check for an id.


ROUTES
- app.use('/api/v1/users', userRouter); // this is called mounting the handler. mounting a new router (userRouter) on a route (/api/v1/user)
  - here we enable a middlewear function called tourRouter to be used on the specific route /api/v1/tours
    when a request hits the server, it will go down the middleware stack untill it higs this function. if the route matches, it will then call the tourRouter() middleware func above
- we call the callback the route handler
- use v1 in order to specify the api version. you can branch off to v2 and not break the v1 of the api
- you can also have optional route parameters using :id?
- const tourRouter = require('./routes/tourRoutes');
  A router like tourRouter is like a mini applicatoin within our own application. A sub applciation for each resource.
  tourRouter has its own routes. our request will then go into here and find its appropriate route
  if the route from within tourRouter is "/:id" it will hit the id route and it will run one of the handlers.
- in tourRoutes.js We no longer need to specify the full route "/api/v1/tours" because we are using the tourRouter middleware that already specifies that we are on teh "api/v1/tours" route


Refactoring our code
- We created a Controllers folder as well as a server.js file and a routes folder
  - Controllers contains all the handlers for the tour and user routes in a separate file. There is a handler for a specific http method. 
  - its important to keep the logic of the handlers separated form any other operations we want to do on the data, like user auth or data varification. for this we use a custom middleware we define
  - the routers will take the request that is comming down the middleware stack and execute the proper controller for that corresponding http request. 
  - we have a tours and a users route. so if the incoming request has the url for tours, it will enter the tours route (app.use('/api/v1/tours', tourRouter)). The same for the users route


Serve static files
- This is how you can serve static files from the browser. localhost:3000/overview.html   
- express will first look for the route you type into the url. if it cant find it, it will then look for the file in the foler we define in this function

Environment Variables & config files
- run this in the terminal: 
  NODE_ENV=development npm start in the git bash
  we manually set a environmetn variable NODE_ENV here from the command line. not permanent. You can set any variable like X = 32
- you can use these to set a database if you use different db for production or development, or you can set NODE_ENV to production or development
- env is the environment global variable that are used to define the environment a app is running. this is set by express, but node.js can set othe env variables look at process.env
- console.log(app.get('env')); 
  console.log(process.env); // this will list all the global env variables available. 
- use a configuration.env file to set envir vars if you need to do it multiple times. 
  - to use a config file, install a package called dotenv. its a package to use config files for setting environment vars
    const dotenv = require('dotenv'); 
    dotenv.config({ path: './config.env' }); // our config.env gets accessed here and the vars are loaded into process.env
    process.env.PORT // this is how you access the env vars if you are using the dotenv package from npm
- we changed our startup scripts to accomodate a dev and a production environment
  {
    "start:dev": "nodemon server",
    "start:prod": "NODE_ENV=production nodemon server.js" 
  }


STATUS codes
- 404 Page not found
- 400 Bad request
- 500 internal server error
- 200 Success
- 201 Created
- 204 No content
- JSEND specification: Used to send json. status and data properties
  res.status(200).json({
    status: 'success', // can either have success, fail, or error
    results: tours.length, // custom property
    requestedAt: req.requestTime, // custom property. we can do this to easily send some data back in the response
    data: { // enveloping the data 
      tours: tours, // in es6 you can just write tours if the key and the value are the same. You do need to make sure the property matches the endpoint name
    },
  })


ES lint
- scans code to find bad coding pratices or potential coding errors
- install extension eslint
  -  npm i eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-config-airbnb eslint-plugin-node eslint-plugin-import eslint-plugin-jsx eslint-plugin-react --save-dev
  - extra pluggins are needed for the airbnb style guide to work
  - next make config files for both prettire and eslint

MONGO DB atlas 
info in config file

-crate a project in atlas, then create a cluster for the project
-a cluster is like an instance of our database

Connecting app to a database
- npm i mongoose
  require mongoose in the server.js file then pass in the connection string into mongoose
- mongoose.connect() returns a promise. so we can use the .then() mentod. when promise if fuffilled, con will be the resolved value of the promise
- the "use*" connect options are jsut for getting rid of some depreication warnings


Mongoose
- Mongoose is a layer of abstraction over mongodb just like express is a layer on top of node. a object data modeling librarey, like mongoose,  is a way for us to write js code to interact with a database.
- mongoose is all about moddles. which are like blueprints for creating documents. you can also crud documents with models. 
- to create a model you need a schema. 
  const tourSchema = new mongoose.Schema({  // pass in the schema as an object
  name: {
    type: String,     // these are schema options. pass in the properties as an object
    required: [true, 'A tour must have a name'],    // you can also pass in an error string in case the name is omitted. this line is callec a validator
  },
  rating: Number,
  price: {
    type: Number,
    required: true
  }
})

const Tour = mongoose.model('Tour', tourSchema);   /// use uppercase for any models or class names. 'Tour' is the model name

- Create a new document from our Tour Schema. like using a class constructor
const testTour = new Tour({   testTour is an instance of the Tour model
  name: 'The Mountain Hiker',
  rating: 4.7,
  price: 497,
});

testTour
  .save()  // to save a documetn to the db its as simple as runing this function. a collection will automatically be created if none exists for that model
  .then((doc) => {    .save() returns a promise. when fuffilled it returns the document we just saved to the db
    console.log(doc);
  })
  .catch((err) => {
    console.log('ERROR ', err);
  });

MVC architecture
- Model layer refers to application data and business logic
- Controller layer handle the apps requests interact with models and send back respoonses to the client ( called the applicaton logic)
- View layer for a graphical interface. consists of teh templates we use to generate the view (the website sent back to the client) this is called the presentation logic
- mvc allows for a more modular app, which is good for scaling and easier to maintain
- Application logic vs Business logic
  - App logic is code that is only concerned about the apps implementation, not the underlying business problem were trying to solve (e.g. showing and selling tours). Code that makes the actually app work
    - managing requests and responses. more about technical stuff. a bridge between model and view layers
  - Bis logic Code that actually solves the business problem we set out to solve. Code directly related to how the bis works, what the bis needs, and the bisness rules
    - Creating new tours in the db. checking if user's password is correct, validating user input data. ensuring only users who bought a tour can review it. Code for when people use the product and services
      Cslculating how many weeks are in a tour would be bis logic and belongs in teh model. this is because it has to do with the bis itself and not with responses, handlers, etc.
- Fat models/thin controllers: offload as much logic as possible into the models and keep controllers as simple and lean as possible

Old functions when using the json file foor testing
All these used to be in the tour Controller
---
Writing to test json file
exports.createTour = (req, res) => {
  console.log(req.body);

  const newID = tours[tours.length - 1].id + 1;
  const id = { id: newID };
  const newTour = Object.assign(id, req.body); // this creates a new object by merging 2 existion objects together. do it like this to not mutate the origional body object.

  tours.push(newTour);

  fs.writeFile(
    `${__dirname}/dev-data/data/tours-simple.json`,
    JSON.stringify(tours),
    (err) => {
      if (err) return console.log('error writing file');
      res.status(201).json({
        status: 'success',
        data: {
          tour: newTour,
        },
      });
    }
  );
};

Check ID middleware
exports.checkID = (req, res, next, val) => {
  eslint-disable-next-line eqeqeq
  const tour = tours.find((el) => el.id == req.params.id);
  console.log(`tour id is ${val}`);
  if (!tour) {
    return res.status(404).json({
      status: 'fail',
      message: 'invalid ID',
    });
  }
  next();
};

VAlidate teh body
exports.checkTour = (req, res, next) => {
  const tour = req.body;

  const { price } = tour;
  if (!req.body.name || price == null) {
    return res.status(400).json({
      status: 'fail',
      message: 'Missing name or Price',
    });
  }

  next();
};


Creating a Tour
-  const newTours = new Tour({});  first creating a document and calling save on the document
   newTours.save();   the document has lots of methods we can use like save 

   using Tour.create({}) is calling the method directly on the tour schema. it also reurns a promise

Filtering data
- use the ? to alow the user to filter data.
  http://localhost:3000/api/v1/tours?duration=5&difficulty=easy
- req.query is how you get an object with all the query params 

There are multiple ways to use the db query

let query = Tour.find(JSON.parse(queryStr));    This creates a Query object so that we can chain multiple methods from teh Query class to it and then execute it later with await
                                                We use Tour.func() to access the Tour collection in  mongoDB
const tours = await Tour.find({   // returns an array of the documents
  duration: 5,
  difficulty: 'easy',
}); 

const tours = await Tour.find()
      .where('duration')
      .equals(5)
      .where('difficulty')
      .equals('easy');

We can do this sort of chaining because all those methods belong to the Query class and Toru.find() returns a query object

Spread syntax Destructuring
- In js, if you say const var1 = obj1 then var1 will just point to obj1 and will not create a hard copy of the obj. so if you modify var1, you will also modify obj1. 
  use destructuring to get a copy of the obj. 

  const queryObj = {...req.query}  // will pull out all the remaing individual properties in the obj. pass all key:value pairs from an object

  As soon as you await the query (using await Tour.find()) the query will execute and will come back with the documents. So, it we do it like that, you wont be able to implement paging or sorting
  or other features. instead, you you have to save teh Tour.find() into a Query obj into a variable, then run whatever query methods on that obj, and only at the end you await the query. 
- What we are trying to do in getAllTours is to create a Query obj so that we keep chaining extra methods to it. 

Greater than or equal to. advanced filtering
- http://localhost:3000/api/v1/tours?duration[gte]=5&difficulty=easy
- queryStr.replace(/(gte|gt|lte|lt)\b/g) use the | for or. \b is to say only match these exact phrases, so it wont match a word with lte in it. teh g mean it will run teh regex multiple times

Field Limiting
- http://localhost:3000/api/v1/tours?fields=name,duration,difficulty,price
- use field limiting to reduce bandwith of requests
- use select operation. using select is called projecting
- the default of select -__v is because we want to at least not include the __v property which mongoose auto adds since it is used internally
- you can hide fields from the client permanently including the select: false property in the schema field you want to hide

Pagination
- if you want page 5 and each page is 10 items (the limit field), you skip the first 50 items and start quering the db
- const limit = req.query.limit * 1 || 100    js feature to set default vals

Ailasing
- if there is a request that is used often, you can make an ailias for that route thats easy for the user to memorize
- We minipulate the query object by using middleware functions to prefill the fields in the url
  First the request goes through the /top-5-cheap route and then the aliasTopTours middleware gets executed. after teh fields are set in teh middleware, the getAllTours func 
  gets run with all the params already set. 

Features class
- we refactored the code so that all the api features are in their own class.
- we need to return this at the end of each method so that we are able to chain mehtod after method. This is the object itself, which has access to all its own methods
- we create a new object of the apifeatures class. we pass in the query object, and the query string that come from express. 

Mongodb agreggation pipeline
- a pipeline is a process where all the documents from a certian collectyion go through where they are processed step by step in ordert to transform them into aggregated resultys
  use to calc averages, min, max distances etc.
- pass in an array of stages that will get exe one at a time in order

  const stats = await Tour.aggregate([   // returns an aggregate object
      {
        $match: { ratingsAverage: { $gte: 4.5 } },    // filters out certian documents. just like a query. usually just a preliminart stage to prepare for other stages
      },
      {
        $group: {
          _id: null,    // this is the field we want to group by. since we wants stats on all the docs we leave it null
          avgRating: { $avg: '$ratingsAverage' },  //$avg and ttc are all mongodb operators. you need to use '$fieldName' just because its what aggregation pipline works
          avgPrice: { $avg: '$price' },
          minPrice: { $min: '$price' },
          maxPrice: { $max: '$price' },
        },
      },
      {
        $sort: { avgPrice: 1 },  // the documets that get passedinto here are the ones that result from being processed in teh above stage. so all teh field names we used above have to be used here
      },
    ]);
- you are also allowed to repeat stages
- $Unwind. will create a copy of the document for each element in fiels's value.
  for the start dates, there are 3 in a array, so it will copy each tour documet 3 times each with only one of the start dates

- to group by the month use a aggregation pipeline operator $month: field (that you want to extract the date from)
- we use $push to create an array of all the names of the tours that are grouped together. 
- use $project: to prevent sending a field to tue user that they dont need 
- use $addField because we expect to have another field named _id in the future?

Virtual properties
- properties you can add to a document that wont get saved to the db. good for things like kilometers, when you already have miles saved in the db. wont persist in the db but 
  will be there when you get the data

  tourSchema.virtual('durationWeeks').get(function () {
    return this.duration / 7;
});

you have to use a reg function because you need access to the this keyword. arrow funcs dont have that. .this points to teh current document
to get it to show up in the results, you have to add an options object into the schema definition
{
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

Mongoose Middleware
- Middleware funcs that run in response to a certian event like a doc being added to the db.
- A hook is the event we are listening to. the 'save' in our function below. we call the fune a 'pre save hook' or pre save middleware

- Document middleware.  Gives you access to the document that is being processed right before it is saved to the db
  tourSchema.pre('save', function () {  // this one runs before the .save() and .create(). does not run on insertMany()
    console.log(this);
  });
  
  tourSchema.pre('save', function (next) { // can have multiple pre middlewares for the same hook
    console.log('Will Save document...');
    next();
  });

  tourSchema.post('save', function (doc, next) {  // has access to the doc that was just saved to the db ('doc'). post middlewares are exe after all teh pre middleware has completed
    console.log(doc); // you dont have this anymore, but you do have the 'doc'
    next();  // no longer needed, but is best pratice to always include it
  });

- Query Middleware: executes before any find query is exe
  tourSchema.pre('find', function (next) {  // the this keyword will point at the current query and not the document for these
    next();
  });

  tourSchema.post(/^find/, function (docs, next) {    // in post middleware you get access to all the 'docs' returned by the query. this middleware runs after teh query was already executed
    console.log(`Query took ${Date.now() - this.start} millisec`);
    console.log(docs);
    next();
  });

- Aggregate middleware
  What we are doing in this func is appending a group to the pipeline right in the beginning to omit the secret tours. doing this at the model level
  we can just add another $match stage to the beginning of the pipeline array.

    tourSchema.pre('aggregate', function (next) { runs before any aggregation pipeline
    this.pipeline().unshift({ $match: { secretTour: { $ne: true } } });  // unshift adds an element to the front of an array. 
    
    console.log(this.pipeline()); // shows the array of stages of teh pipeline
    next();
  });

- Data validation
  Checks whether the data given is in the right format for the document schema, and that values are entered for the required fields.
  Sanitation. makes sure there is no milicous code being entered into the database. remove unwanted characters. never accept data coming from a user as it is

  required: [true, 'A tour must have a name'],  this is a type of validator
  maxlength: [40, 'A tour name must have less or equal to 40 chars'],
  minlength: [10, 'A tour name must have at least 10 characters'],      these validators are only available for strings
  enum validator works for strings
  min and max validators for numbers and dates

  - Custom Validators. these return true or false
      priceDiscount: {
          type: Number,
          validate: {
            validator: function (val) {  // func has access to the value that was passed in
              return val < this.price;
            },
            message:
              'Discount price ({VALUE}) should be less than the regular price',    /// message has access to the value as well. its just internal to mongoose
          },
        },
  It turns out that this validator wont work on a update because the .this keyword only applies to NEW Document createion
  Can also use a library called validator
    const validator = require('validator');
    validate: [validator.isAlpha, 'Tour name must only contain letters'],
